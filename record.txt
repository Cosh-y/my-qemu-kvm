QEMU := qemu-system-aarch64
KERNEL := /home/m/buildroot/output/images/Image
ROOTFS := /home/m/buildroot/output/images/rootfs.ext4
QEMU_FLAGS := -M virt,gic-version=3,virtualization=on \
              -cpu cortex-a57 \
			  -nographic \
			  -smp 2 \
			  -m 2048 \
			  -kernel $(KERNEL) \
			  -append "root=/dev/vda rw console=ttyAMA0" \
			  -drive if=none,file=$(ROOTFS),format=raw,id=hd0 \
			  -device virtio-blk-device,drive=hd0 

test_qemu:
	$(QEMU) $(QEMU_FLAGS)

测试环境（Qemu、Qemu 上运行的 Linux HostOS、 HostOS 使用的 rootfs）
为了能在测试环境 Linux 上运行 mini-qemu。首先需要利用交叉编译，编译出 aarch64 架构的 mini-qemu 可执行文件。
其次需要保证测试环境 Linux 上有 mini-qemu 依赖的动态链接库。构建 mini-qemu 时的链接环节是决定这些动态链接库的关键。
rustc 在编译 mini-qemu 时，编译过程是直接调用 C 编译器完成的。
通过指定 C 编译器为 Buildroot 提供的交叉编译器，可以确保链接到正确的 aarch64 架构的动态链接库。
这些动态链接库在 Buildroot 构建的 Linux 系统镜像中已经包含。

对 buildroot 项目的使用(具体每一步都干了什么目前还不太清楚)
1. 下载 Buildroot 源码
   git clone
2. 配置 Buildroot
   make menuconfig
3. 修改 Linux kernel 配置
   make linux-menuconfig
4. 开始编译
   make -j$(nproc)
5. 编译完成后，Buildroot 会在 output/images 目录下生成 Linux 内核镜像（Image）和根文件系统镜像（rootfs.ext4）。


一段代码写出来之后，他用到哪些动态链接库，为什么会在编译期决定？
自己编写的代码会调用一些外部库函数，编译期发现这些函数只有声明没有定义，就会在编译产物中留下对这些函数的引用（等待被重定向或者被指定动态链接库）。
链接器会找到实现这些函数的动态链接库，动态链接库中往往有多个版本的对这个函数的不同实现，链接器会选择最新的版本，把这个版本号记录在编译产物中对应的引用位置。
编译产物实际运行时，会在运行环境中的动态链接库中寻找对应版本的函数实现。如果运行环境中动态链接库版本过老，找不到对应版本的函数实现，就会报错。

如果要把你的总结修改得天衣无缝，应该是这样的：

1. 编码阶段：通过 #include 和函数调用，声明了对外部功能的需求意图。
2. 构建配置阶段：通过编译器参数（如 -lfoo），指定了满足该意图的动态库文件名（如 libfoo.so）。
3. 链接阶段（编译期）：
链接器找到对应的 .so 文件。
发现其中有多个版本的函数实现。
链接器选择最新/默认的版本（例如 func@@V2）。
链接器将库的文件名（SONAME）和函数的具体版本号同时“烙印”在编译产物中。
4. 运行阶段：
加载器根据“烙印”的库文件名加载运行环境中的 .so。
加载器根据“烙印”的版本号寻找对应的函数实现。
如果环境里的库太老（没有该版本号），报错。

也就是构建时，我告诉编译器（或者依赖编译器的默认配置）需要哪些动态链接库，链接期这些库的名字和提供的函数实现的版本会被烙印在编译产物中，运行时，会在运行环境中找同样名字的动态链接库，并在其中找同样版本的函数实现。

具体为什么用 buildroot 下面的 gcc 来链接，产物所依赖的动态链接库就是测试环境 rootfs 中所具备的了？

HostOS 使用 PSCI 协议进行多核启动时可能存在的问题
如果使用 SMC 调用 EL3 层的功能，那么没什么问题；如果使用 HVC 调用 EL2 层的功能，因为 EL2 stub 已经被我们替换了，我们也没有实现相应的功能，所以可能有问题。

GuestOS 想启动从核呢？我们现在不支持这么复杂的 GuestOS.

qemu 中查看寄存器状态

m@m-ThinkPad-T14-Gen-2i:~/文档/mykvm$ file ~/buildroot/output/build/linux-6.12.47/vmlinux
/home/m/buildroot/output/build/linux-6.12.47/vmlinux: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV), statically linked, BuildID[sha1]=6a9baa2efeedc511de4d5626870e637bf69ccf26, not stripped
m@m-ThinkPad-T14-Gen-2i:~/文档/mykvm$ file ~/buildroot/output/images/Image
/home/m/buildroot/output/images/Image: Linux kernel ARM64 boot executable Image, little-endian, 4K pages

synchronous exception 的处理逻辑，单独处理 hvc

virt_to_phys 的局限：virt_to_phys 通常只适用于线性映射区域（Linear Mapping，如 kmalloc 分配的内存）。对 vmalloc 区域的地址使用 virt_to_phys 可能会得到错误的物理地址。

我写了一段汇编代码，想让他运行在 el2,处理上层的 hvc 调用。我使用 hvc_set_vectors 将其设置到 vbar_el2（先使用 virt_to_phys 获取其物理地址） ，但迟迟不能正常运行。
有人说我这段作为内核模块的汇编代码，位于一段 vmalloc 开辟的内存上，他不一定位于连续的物理内存上，这是事实吗？会影响吗？

我把我的代码整体拷贝到另一个物理地址上，他还能正确运行吗？代码里的跳转等操作，使用的会是虚拟地址吗？
位置无关代码（Position Independent Code, PIC）

在设置 vbar_el2 时，要注意 vbar_el2 寄存器是 Per-CPU 的，所以需要利用 Linux 的接口，在每个 CPU 上分别设置 vbar_el2。

关于 Arm 中的 sp_elx
我们在进入 GuestOS 前，会设置好 sp_el1 为 GuestOS 的栈顶地址。但在使用 hvc 进入 el2 stub 前，我们没有设置 sp_el2。
这是因为现在的 el2 stub 使用纯汇编代码，不会使用栈，所以不需要设置 sp_el2。
但如果 el2 stub 中使用了 C 代码，或者需要使用栈，那么就需要在进入 el2 stub 前，设置好 sp_el2 了。

需安装 rustc bindgen-cli clang llvm 和 交叉编译环境

make LLVM=1 ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig
需配置 rust support / rust samples / virtualization support & no kvm enable
make LLVM=1 ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j8

Intel x86_64
make LLVM=1 menuconfig
开启 Guneral setup -> Rust support
开启 virtualization 关闭 kvm support
可以裁剪的内容：
A. 显卡和多媒体
Device Drivers -> Graphics support:
Device Drivers -> Sound card support:
B. 网络与无线
Device Drivers -> Network device support:
  Wireless LAN
  Ethernet driver support
  保留 Virtio network driver
Networking support
C. 冷门的文件系统格式
  保留 ext4 Tmpfs Devtmpfs
D. USB
Device Drivers -> USB support:
make LLVM=1 -j8

qemu-system-aarch64 \
  -machine virt \
  -cpu cortex-a57 \
  -m 512M \
  -kernel ~/chy/linux-6.18.5/arch/arm64/boot/Image \
  -drive file=/home/m/chy/busybox-1.36.1/disk.img,format=raw,id=hd0,if=virtio \
  -append "root=/dev/vda1 console=ttyAMA0 rw" \
  -nographic

反汇编 .o 查看 kvm_el2_stub.S 各指令的地址
aarch64-linux-gnu-objdump -d rkvm/kvm_el2_stub.o


rust for linux 中关于内存的一些接口
根据搜索结果中的内核 API 定义：

alloc_pages(gfp_mask, order):
作用: 分配 2^order 个物理连续的页面。
返回: 指向第一个 struct page 的指针。
适用场景: VMCS 要求物理地址连续，alloc_pages 保证物理连续（这一点优于 vmalloc，后者物理不连续）。

page_address(page):
作用: 给定 struct page *，返回其对应的内核逻辑地址（虚拟地址）。
原理: 对于线性映射区（Low Memory），它进行简单的线性偏移计算（__va(phys)）。对于高端内存（HighMem，这在 64 位内核中很少用于内核数据），可能需要 kmap，但 GFP_KERNEL 分配的通常是线性映射区的。

virt_to_phys(kaddr):
作用: 将内核虚拟地址转换为物理地址。
公式: 也就是 Phys = Virt − PAGE_OFFSET (简化版)。
注意: 必须用于线性映射区的地址（由 kmalloc, alloc_pages, __get_free_pages 分配的），不能用于 vmalloc 分配的地址。

vmalloc vs alloc_pages:
VMCS 要求: VMCS 必须是 4KB 对齐且物理连续的。
结论: 不要使用 vmalloc。vmalloc 分配的内存虚拟连续但物理不连续，且转换物理地址比较麻烦（需要查页表），不适合作为 VMCS 指针 78。请坚持使用 alloc_pages 或 __get_free_pages。
针对 VMCS 的特别提示
对齐 (Alignment): alloc_pages 在 order=0 (1页) 时天然满足 4KB 对齐，这符合 VMCS 的要求。
清零: VMCS 区域在写入 Revision ID 之前，其余部分最好清零。使用 __GFP_ZERO 标志是最快的方法。
Bindgen 宏问题: 内核中很多转换（如 page_to_phys）是 C 语言宏或 static inline 函数。bindgen 有时无法生成这些绑定。
你可能需要自己编写一个小的 C Helper 函数包装这些宏，让 Rust 调用。


Vec 包含在 kernel::prelude 中，通常你的模块文件头部会包含它：

use kernel::prelude::*;
use kernel::alloc::flags; // 如果需要用到分配标志（但在 Vec 中通常隐含为 GFP_KERNEL）
2. 关键 API 变化 (Push vs Try_Push)
操作	    标准 Rust (User Space)	Rust for Linux (Kernel)	说明
创建	    Vec::new()	            Vec::new()	new 不分配内存，是安全的。
预分配	    Vec::with_capacity(10)	Vec::try_with_capacity(10)?	必须处理内存分配失败（返回 Result）。
添加元素	 v.push(x)	            v.try_push(x)?	最重要：push 会 Panic，内核中被禁用或不推荐；try_push 返回 Result。
扩展	    v.extend(iter)	        v.try_extend(iter)?	同样需要处理失败。