QEMU := qemu-system-aarch64
KERNEL := /home/m/buildroot/output/images/Image
ROOTFS := /home/m/buildroot/output/images/rootfs.ext4
QEMU_FLAGS := -M virt,gic-version=3,virtualization=on \
              -cpu cortex-a57 \
			  -nographic \
			  -smp 2 \
			  -m 2048 \
			  -kernel $(KERNEL) \
			  -append "root=/dev/vda rw console=ttyAMA0" \
			  -drive if=none,file=$(ROOTFS),format=raw,id=hd0 \
			  -device virtio-blk-device,drive=hd0 

test_qemu:
	$(QEMU) $(QEMU_FLAGS)

测试环境（Qemu、Qemu 上运行的 Linux HostOS、 HostOS 使用的 rootfs）
为了能在测试环境 Linux 上运行 mini-qemu。首先需要利用交叉编译，编译出 aarch64 架构的 mini-qemu 可执行文件。
其次需要保证测试环境 Linux 上有 mini-qemu 依赖的动态链接库。构建 mini-qemu 时的链接环节是决定这些动态链接库的关键。
rustc 在编译 mini-qemu 时，编译过程是直接调用 C 编译器完成的。
通过指定 C 编译器为 Buildroot 提供的交叉编译器，可以确保链接到正确的 aarch64 架构的动态链接库。
这些动态链接库在 Buildroot 构建的 Linux 系统镜像中已经包含。

对 buildroot 项目的使用(具体每一步都干了什么目前还不太清楚)
1. 下载 Buildroot 源码
   git clone
2. 配置 Buildroot
   make menuconfig
3. 修改 Linux kernel 配置
   make linux-menuconfig
4. 开始编译
   make -j$(nproc)
5. 编译完成后，Buildroot 会在 output/images 目录下生成 Linux 内核镜像（Image）和根文件系统镜像（rootfs.ext4）。


一段代码写出来之后，他用到哪些动态链接库，为什么会在编译期决定？
自己编写的代码会调用一些外部库函数，编译期发现这些函数只有声明没有定义，就会在编译产物中留下对这些函数的引用（等待被重定向或者被指定动态链接库）。
链接器会找到实现这些函数的动态链接库，动态链接库中往往有多个版本的对这个函数的不同实现，链接器会选择最新的版本，把这个版本号记录在编译产物中对应的引用位置。
编译产物实际运行时，会在运行环境中的动态链接库中寻找对应版本的函数实现。如果运行环境中动态链接库版本过老，找不到对应版本的函数实现，就会报错。

如果要把你的总结修改得天衣无缝，应该是这样的：

1. 编码阶段：通过 #include 和函数调用，声明了对外部功能的需求意图。
2. 构建配置阶段：通过编译器参数（如 -lfoo），指定了满足该意图的动态库文件名（如 libfoo.so）。
3. 链接阶段（编译期）：
链接器找到对应的 .so 文件。
发现其中有多个版本的函数实现。
链接器选择最新/默认的版本（例如 func@@V2）。
链接器将库的文件名（SONAME）和函数的具体版本号同时“烙印”在编译产物中。
4. 运行阶段：
加载器根据“烙印”的库文件名加载运行环境中的 .so。
加载器根据“烙印”的版本号寻找对应的函数实现。
如果环境里的库太老（没有该版本号），报错。

也就是构建时，我告诉编译器（或者依赖编译器的默认配置）需要哪些动态链接库，链接期这些库的名字和提供的函数实现的版本会被烙印在编译产物中，运行时，会在运行环境中找同样名字的动态链接库，并在其中找同样版本的函数实现。

具体为什么用 buildroot 下面的 gcc 来链接，产物所依赖的动态链接库就是测试环境 rootfs 中所具备的了？

HostOS 使用 PSCI 协议进行多核启动时可能存在的问题
如果使用 SMC 调用 EL3 层的功能，那么没什么问题；如果使用 HVC 调用 EL2 层的功能，因为 EL2 stub 已经被我们替换了，我们也没有实现相应的功能，所以可能有问题。

GuestOS 想启动从核呢？我们现在不支持这么复杂的 GuestOS.

qemu 中查看寄存器状态

m@m-ThinkPad-T14-Gen-2i:~/文档/mykvm$ file ~/buildroot/output/build/linux-6.12.47/vmlinux
/home/m/buildroot/output/build/linux-6.12.47/vmlinux: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV), statically linked, BuildID[sha1]=6a9baa2efeedc511de4d5626870e637bf69ccf26, not stripped
m@m-ThinkPad-T14-Gen-2i:~/文档/mykvm$ file ~/buildroot/output/images/Image
/home/m/buildroot/output/images/Image: Linux kernel ARM64 boot executable Image, little-endian, 4K pages

synchronous exception 的处理逻辑，单独处理 hvc

virt_to_phys 的局限：virt_to_phys 通常只适用于线性映射区域（Linear Mapping，如 kmalloc 分配的内存）。对 vmalloc 区域的地址使用 virt_to_phys 可能会得到错误的物理地址。

我写了一段汇编代码，想让他运行在 el2,处理上层的 hvc 调用。我使用 hvc_set_vectors 将其设置到 vbar_el2（先使用 virt_to_phys 获取其物理地址） ，但迟迟不能正常运行。
有人说我这段作为内核模块的汇编代码，位于一段 vmalloc 开辟的内存上，他不一定位于连续的物理内存上，这是事实吗？会影响吗？

我把我的代码整体拷贝到另一个物理地址上，他还能正确运行吗？代码里的跳转等操作，使用的会是虚拟地址吗？
位置无关代码（Position Independent Code, PIC）

在设置 vbar_el2 时，要注意 vbar_el2 寄存器是 Per-CPU 的，所以需要利用 Linux 的接口，在每个 CPU 上分别设置 vbar_el2。

关于 Arm 中的 sp_elx
我们在进入 GuestOS 前，会设置好 sp_el1 为 GuestOS 的栈顶地址。但在使用 hvc 进入 el2 stub 前，我们没有设置 sp_el2。
这是因为现在的 el2 stub 使用纯汇编代码，不会使用栈，所以不需要设置 sp_el2。
但如果 el2 stub 中使用了 C 代码，或者需要使用栈，那么就需要在进入 el2 stub 前，设置好 sp_el2 了。

需安装 rustc bindgen-cli clang llvm 和 交叉编译环境

make LLVM=1 ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig
需配置 rust support / rust samples / virtualization support & no kvm enable
make LLVM=1 ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j8

qemu-system-aarch64 \
  -machine virt \
  -cpu cortex-a57 \
  -m 512M \
  -kernel ~/chy/linux-6.18.5/arch/arm64/boot/Image \
  -drive file=/home/m/chy/busybox-1.36.1/disk.img,format=raw,id=hd0,if=virtio \
  -append "root=/dev/vda1 console=ttyAMA0 rw" \
  -nographic

反汇编 .o 查看 kvm_el2_stub.S 各指令的地址
aarch64-linux-gnu-objdump -d rkvm/kvm_el2_stub.o